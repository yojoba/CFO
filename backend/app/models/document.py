"""Document models for file storage and RAG."""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Text, Enum as SQLEnum, Float, Numeric, Date
from sqlalchemy.orm import relationship
from datetime import datetime, date
import enum
from app.models.database import Base
from pgvector.sqlalchemy import Vector


class DocumentType(str, enum.Enum):
    """Document type enumeration."""
    INVOICE = "invoice"
    LETTER = "letter"
    CONTRACT = "contract"
    RECEIPT = "receipt"
    OTHER = "other"


class DocumentStatus(str, enum.Enum):
    """Document processing status."""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


class Document(Base):
    """Document model for uploaded files."""
    
    __tablename__ = "documents"
    
    id = Column(Integer, primary_key=True, index=True)
    filename = Column(String, nullable=False)
    original_filename = Column(String, nullable=False)
    display_name = Column(String, nullable=True)  # Human-readable name generated by AI
    file_path = Column(String, nullable=False)  # Original file path
    ocr_pdf_path = Column(String, nullable=True)  # Searchable PDF with OCR layer
    file_size = Column(Integer)  # in bytes
    mime_type = Column(String)
    document_type = Column(SQLEnum(DocumentType), default=DocumentType.OTHER)
    category = Column(String, nullable=True, index=True)  # Theme/category (Impots, Assurance, etc.)
    status = Column(SQLEnum(DocumentStatus), default=DocumentStatus.PENDING)
    storage_year = Column(Integer, nullable=True, index=True)  # Year for filing cabinet organization
    
    # Extracted metadata
    extracted_text = Column(Text, nullable=True)
    extracted_data = Column(Text, nullable=True)  # JSON string
    
    # Document intelligence metadata
    importance_score = Column(Float, nullable=True)  # Score 0-100
    document_date = Column(Date, nullable=True)  # Date extracted from document
    deadline = Column(Date, nullable=True)  # Deadline if applicable
    extracted_amount = Column(Numeric(10, 2), nullable=True)  # Main amount (for invoices/receipts)
    currency = Column(String, default="CHF", nullable=True)
    keywords = Column(Text, nullable=True)  # JSON array of important keywords
    classification_confidence = Column(Float, nullable=True)  # Confidence level 0-1
    
    # Duplicate detection
    file_hash = Column(String, nullable=True, index=True)  # SHA256 hash of file content
    is_duplicate = Column(Integer, default=False)  # Boolean: is this a duplicate?
    duplicate_of_id = Column(Integer, ForeignKey("documents.id"), nullable=True)  # Reference to original
    similarity_score = Column(Float, nullable=True)  # Similarity score with original (0-1)
    
    # Ownership and timestamps
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    owner = relationship("User", back_populates="documents")
    chunks = relationship("DocumentChunk", back_populates="document", cascade="all, delete-orphan")
    transactions = relationship("Transaction", back_populates="document", cascade="all, delete-orphan")
    
    # Index for filing cabinet queries: (user_id, storage_year, document_type)
    __table_args__ = (
        {"extend_existing": True}
    )


class DocumentChunk(Base):
    """Document chunk for RAG with vector embeddings."""
    
    __tablename__ = "document_chunks"
    
    id = Column(Integer, primary_key=True, index=True)
    document_id = Column(Integer, ForeignKey("documents.id"), nullable=False)
    content = Column(Text, nullable=False)
    chunk_index = Column(Integer, nullable=False)  # Order in document
    
    # Vector embedding (1536 dimensions for text-embedding-3-small)
    embedding = Column(Vector(1536), nullable=True)
    
    # Metadata
    page_number = Column(Integer, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    document = relationship("Document", back_populates="chunks")
